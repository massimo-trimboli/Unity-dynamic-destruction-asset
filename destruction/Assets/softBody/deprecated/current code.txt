using GK;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class softBuddy : MonoBehaviour
{
    //mesh info
    MeshFilter ogMeshFilter;
    Mesh mesh2;

    List<Vector3> vertexList = new List<Vector3>();
    List<Vector3> normalList = new List<Vector3>();
    int[] triArray;
    //for convex hull optimisation
    List<Vector3> vertexListOptimised = new List<Vector3>();
    List<Vector3> normalListOptimsed = new List<Vector3>();
    List<int> triListOptimsed;

    Dictionary<int, Vector3> vertexDictionary = new Dictionary<int, Vector3>();


    List<SphereCollider> sphereColliderList = new List<SphereCollider>();
    List<GameObject> physicsVertexList = new List<GameObject>();
    GameObject centerOfMass;


    //public variables
    public bool optimisedReducPoints = true;

    public bool rbUseGravity = true;
    public float colliderRadius = 0.1f;
    public float rbMass = 1;
    public float rbDrag = 1;

    public float springForce = 50;



    void Awake()
    {
        //assigner mesh / vertex / normals
        ogMeshFilter = GetComponent<MeshFilter>();
        ogMeshFilter.mesh.GetVertices(vertexList);
        ogMeshFilter.mesh.GetNormals(normalList);

        triArray = ogMeshFilter.mesh.triangles;

        // passer de possition locale à position monde
        for (int i = 0; i < vertexList.Count; i++)
        {
            //je comprends pas entierement la ligne de code mais ca va etre pour plus tard
            vertexList[i] = transform.localToWorldMatrix.MultiplyPoint3x4(vertexList[i]);
        }

        // //////////////////////
        //optimisations utilisant le script ConvexHullCalculator par Eshan Moradi
        // https://github.com/ehsanwwe/Unity-SoftBody-physics/blob/main/Assets/ProSoftBody/ConvexHullCalculator.cs
        if (optimisedReducPoints)
        {
            new ConvexHullCalculator().GenerateHull(
                vertexList,
                false,
                ref vertexListOptimised,
                ref triListOptimsed,
                ref normalListOptimsed
            );
            vertexList = vertexListOptimised;
            normalList = normalListOptimsed;
            triArray = triListOptimsed.ToArray();
        }
        // //////////////////////

        // //////////////////////
        for (int i = 0; i < ogMeshFilter.mesh.vertexCount; i++)
        {
            Vector3 originalVertex = ogMeshFilter.mesh.vertices[i];

            float bestDist = float.MaxValue;
            Vector3 relativePosition = new Vector3();

            for (int j = 0; j < vertexList.Count; j++)
            {
                float d = Vector3.Distance(originalVertex, vertexList[j]);
                if (d < bestDist)
                {
                    bestDist = d;
                    relativePosition = vertexList[j] - originalVertex;
                }
            }
            relativePosition = transform.TransformPoint(relativePosition);
            vertexDictionary.Add(i, relativePosition);
        }
        // //////////////////////

        //creer nouvell mesh et y assigner l'info de la
        //mesh originale ou de la mesh optimisée
        mesh2 = new Mesh();
        mesh2.MarkDynamic();
        mesh2.SetVertices(vertexList);
        mesh2.SetNormals(normalList);
        mesh2.triangles = triArray;
        ogMeshFilter.mesh = mesh2;


        //create physicsPoint for each vertex
        foreach (var vert in vertexList)
        {
            //creer objet pour vertex
            var tempObj = new GameObject("point " + vertexList.IndexOf(vert));

            tempObj.transform.parent = transform;
            tempObj.transform.position = vert;

            //rajouter collider
            SphereCollider collider = tempObj.AddComponent<SphereCollider>();
            collider.radius = colliderRadius;

            sphereColliderList.Add(collider);

            //rajouter rigidbody
            Rigidbody rb = tempObj.AddComponent<Rigidbody>();
            rb.mass = rbMass / vertexList.Count;
            rb.drag = rbDrag;
            rb.useGravity = rbUseGravity;


            physicsVertexList.Add(tempObj);
        }


        //center of mass
        Vector3 TempCenterOM = new Vector3(0, 0, 0);
        //position moyenne
        foreach (var vert in vertexList)
        {
            TempCenterOM += vert;
        }
        TempCenterOM = TempCenterOM / vertexList.Count;
        {
            var tempObj = new GameObject("centerOfMass");
            tempObj.transform.parent = transform;
            tempObj.transform.position = TempCenterOM;

            //rajouter collider et rb
            SphereCollider collider = tempObj.AddComponent<SphereCollider>();
            collider.radius = colliderRadius;
            sphereColliderList.Add(collider);
            Rigidbody rb = tempObj.AddComponent<Rigidbody>();
            rb.mass = rbMass / vertexList.Count;
            rb.drag = rbDrag;
            rb.useGravity = rbUseGravity;

            centerOfMass = tempObj;
        }


        //ignorer collisions entre vertexes
        foreach (var colider1 in sphereColliderList)
        {
            foreach (var collider2 in sphereColliderList)
            {
                Physics.IgnoreCollision(colider1, collider2, true);
            }
        }


        //get les edges
        List<Vector2Int> edgeList = new List<Vector2Int>();

        for (int i = 0; i < triArray.Length; i += 3)
        {
            int point1 = triArray[i];
            int point2 = triArray[i + 1];
            int point3 = triArray[i + 2];

            //print("i:" + i + " = " + triArray[i]+" = "+ edgeDictionary[triArray[i]]);

            //rajouter les 3 cotes du triangle dans la liste
            edgeList.Add(new Vector2Int(point1, point2));
            edgeList.Add(new Vector2Int(point2, point3));
            edgeList.Add(new Vector2Int(point3, point1));
        }
        //enlever les edge en double
        {
            List<Vector2Int> tempList = new List<Vector2Int>();
            foreach (var edge in edgeList)
            {
                bool inList = false;
                foreach (var edge2 in tempList)
                {
                    if (edge == edge2)
                    {
                        inList = true;
                        break;
                    }
                }
                if (!inList)
                {
                    tempList.Add(edge);
                }
            }
            edgeList = tempList;
        }

        //rajouter springs pour chaque edge
        foreach (var edge in edgeList)
        {
            GameObject obj = physicsVertexList[edge.x];
            GameObject target = physicsVertexList[edge.y];

            var joint = obj.AddComponent<SpringJoint>();
            joint.connectedBody = target.GetComponent<Rigidbody>();

            joint.autoConfigureConnectedAnchor = false;
            joint.maxDistance = Vector3.Distance(obj.transform.position, target.transform.position);
            joint.minDistance = Vector3.Distance(obj.transform.position, target.transform.position);

            joint.spring = 100f;
        }

        // ad spring for centeer of mass to keep every vertex at a distance to the center
        foreach (var vert in physicsVertexList)
        {
            /*var joint = vert.AddComponent<SpringJoint>();
            joint.connectedBody = centerOfMass.GetComponent<Rigidbody>();

            joint.autoConfigureConnectedAnchor = false;
            joint.maxDistance = Vector3.Distance(vert.transform.position, centerOfMass.transform.position);
            joint.minDistance = Vector3.Distance(vert.transform.position, centerOfMass.transform.position);

            joint.spring = springForce;*/

            var joint = vert.AddComponent<ConfigurableJoint>();
            joint.connectedBody = centerOfMass.GetComponent<Rigidbody>();

            joint.autoConfigureConnectedAnchor = true;
            joint.xMotion = ConfigurableJointMotion.Limited;
            joint.yMotion = ConfigurableJointMotion.Limited;
            joint.zMotion = ConfigurableJointMotion.Limited;

            joint.angularXMotion = ConfigurableJointMotion.Limited;
            joint.angularYMotion = ConfigurableJointMotion.Limited;
            joint.angularZMotion = ConfigurableJointMotion.Limited;
        }
    }

    // Update is called once per frame
    void Update()
    {
        Vector3[] tempVertexList = new Vector3[ogMeshFilter.mesh.vertexCount];
        for (int i = 0; i < tempVertexList.Length; i++)
        {
            Vector3 renderVertex = transform.TransformPoint(ogMeshFilter.mesh.vertices[i]);
            Vector3 offset = vertexDictionary[i];
            tempVertexList[i] = renderVertex + offset;
        }

        ogMeshFilter.mesh.vertices = tempVertexList;
        ogMeshFilter.mesh.RecalculateBounds();
        ogMeshFilter.mesh.RecalculateNormals();
    }
}